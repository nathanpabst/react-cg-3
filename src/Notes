_______Section 4 notes: React State & Working with Events__________
    

Module 58. Child-to-Parent Component Communication (bottom-up)...
    Pass expense data to the new expense component...
        1. add a new prop to ExpenseForm (within the NewExpense component)


Module 57. Two-Way Binding...
    For inputs...we listen for changes and are able to pass a new value back into the input to reset or change the input programmatically.
    Example, when the form has been submitted...
        1. we accept the user input and assign the value to state
        2. and then we pass back a function to clear each form value.
    To accomplish two-way binding, we add the 'value' attribute on the input and assign the value to state. then we pass back a function like
    'setEnteredAmount('')' to clear the field.  

Module 56. Handling Form Submission...
    To capture all of the data within the form, we add type="submit" to the button and add the onSubmit() event in the opening <Form> tag. 
    The default browser behavior for the onSubmit() function is to send a request to the server and re-load the page.
    To disable this default behavior (i.e. prevent the page from re-loading when the submit button is pressed), we use 
    the preventDefault() method.  

Module 55. Updating State that depends on the previous state...
    IMPORTANT: Whenever you need to update state and are dependant upon the value of the previous state, use the following syntax. 
    This is the best practice because React guarantees that the state snapshot will always be the latest version (considering all scheduled state updates)
    setUserInput((prevState) => {
      return { ...prevState, enteredTitle: event.target.value };
     }); 
     ...best practice because React schedules state updates (not instantly). sooooooo if you are not using the anonymous arrow function syntax/example, and 
     schedule several state updates at the same time, you could be depending on an outdated or incorrect snapshot of state 

Module 49. Closer look at the 'useState' hook...
    'useState' registers some 'value' as a new state for the component in which it is being called.
    More specifically...React registers or assigns a unique state value for each component instance. 
    Each instance of a component has its own unique definition of state, which is detached from the state values 
    of all the other component instances. For example, we have one definition of the 'ExpenseItem' component,
    the function will be called 4 times (as per instruction within the Expenses.js file). Each time the function is called,
    a new and separate definition of state is created and managed independently by React. When a user interacts with the UI 
    to modify the value of a component instance--via a click event listener--only the definition of state/value for this particular 
    instance will be updated...the state values for each of the remaining instances will remain un-changed. 
    Additionally, because 'state' is changed on a per component/instance basis, whenever the state of one component instance 
    changes...React will only update and re-evaluate that specific instance.
    When using the 'useState' function, we do not assign a value using the '=' operator (so using the 'const' keyword...iso'kay)
    ...we call the state updating function. react is managing the concrete value somewhere else. 
    ...React keeps track of the instance of 'useState' within each component...when useState is called for the first time
    ...the argument, which in this case is '(props.title)', is taken as the initial value
    ...if the component is re-executed...react will not re-initialize the state
    ...react detects that 'state' was initialized in the past and will grab/return the latest version of state
    ...sooooooo the '(props.title)' argument inserted into the useState() function is only considered the first time a component 
    instance is executed.
    Simply put...you register a state value with the 'useState()' function
    ...the 'useState()' function returns two values...the value itself and an updating function.
    ...the updating function will be called whenever the state value should change 
    ...and you use the first element/value when you want to use the state value as output in the JSX code. 
    ...React will do the rest...it will re-execute the component function and re-evaluate the JSX code whenever the state changes. 
    ...Sans 'state', the UI will never change. 
    ...By using 'state' and event listeners, we ensure that the application can respond to user input and will result in a 
    visible update change on the screen.    
    More info on State and lifecycle methods: https://reactjs.org/docs/state-and-lifecycle.html
    More info on the 'useState' hook: https://reactjs.org/docs/hooks-reference.html#usestate


Module 48. Working with State...
    To prompt react to re-render/re-evaluate a component, we import the 'useState' function which is 
    provided by the react library. EX. import React, {useState} from 'react'; --a.k.a. a react hook
    All react hooks start with the prefix 'use...' and must be called within the component function 
    (NOTE...hooks should not be used within nested functions). the useState function allows the component 
    to be called again and to assign values as 'state', when we call the function. useState returns an 
    array containing the variable/value and an updating function. We use array destructing to accomplish this.
    EX. const [title, setTitle] = useState(props.title) --order matters here...'title' is the managed value 
    the second element is a function that we use to set the updated state value. 
    Use the concept of 'state', if you have data which may change and will need to be reflected in the UI.
    With state you can set and change values and when you change values, (unlike a variable) React will re-evaluate the component
    in which the state was registered. 

Module 47. How Component Functions are Executed...
    Components are regular functions that return JSX. Functions must be called. We use these functions
    like HTML elements in the JSX code. Using a component, within the return statement, is similar to a 
    function call. By using components in JSX code, we make react aware of the component functions. when
    react evaluates the JSX code it will call each component function and evaluate its JSX code until all 
    of the code has been called/evaluated. It then react evaluates the overall result and translates it to 
    DOM instructions which then render on the screen. 
    React starts with the index.js file (reactDOM.render(<App />, document.getElementById('root')))
    This is all done when the application is initially rendered...it doesn't repeat itself. In order to update
    or re-render a component, we use the concept of 'State'. 

Module 46. HTML Button Element: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button 

_______Section 3 notes: React Basics & Working with Components__________
Section 43. Alternative Function Syntax (arrow functions)...
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
EX. syntax: const App = () => {}
Section 39. The concept of Composition ('children props')...
    About combining components & extracting HTML/JSX code. For example, creating a wrapper component
    i.e. Card that can be used often to reduce code & style duplication and keep components clean.
    the building blocks that make up a UI 

Assignment One...
Expenses...
1. Create a new component, in the components folder, called Expenses that will be responsible for displaying our expenses
2. export the Expenses function
3. write a function called Expenses containing a root JSX element (div) in the return statement
4. import the ExpenseItems component 
5. paste the ExpenseItems self-closing components from App.js into the div
6. add props to the Expenses function to make the expense item properties from App.js available   
7. import the Expenses.css file & add a className to the root element 
App.js...
1. import the Expenses component
2. remove the ExpenseItems import statement
3. delete the ExpenseItems self-closing components from App.js (this was moved into the root JSX element of the Expenses component.   
4. forward the props from App.js to the Expenses component by adding a self-closing Expenses component within the root element of App.js
    Expenses should include an 'items' prop pointing to the const 'expenses' array

Section 36. passing data via props
    components can be truly re-usable and configurable by using the concept of 'props'. (shorthand for properties)
    i.e. passing data from one component to another.   

Section 33. writing more complex JSX code
    You can only have one single root element per return statement/JSX code snippet.
    Workaround...create one div element to contain any additional elements that you need. 


Section 32. building a first custom component
    A component, in React, is merely a JavaScript function. 
    Always use the following steps...
    1. Create a component (folder, file, and function)
    2. Export the component
    3. Import the component in the file where you want to use it. e.g. App.js 

Section 31. How React Works
    React allows you to create re-usable and reactive components consisting of HTML & JavaScript (and CSS)
    With React, we are building our own custom HTML elements. React is all about components 
    (which are custom HTML elements) and is accomplished using a declarative approach 
    i.e. we define the desired target state(s) and let React figure out the actual JS DOM instructions. 
    (rather than an imperative approach...how it is done with JS...clear step by step instructions). 

Section 30. Introducing JSX
    JSX (JavaScript XML) is essentially HTML code inside of JavaScript. 

Section 29. Analyzing a standard React Project
    SRC is where all React code (ultimately this code is all JavaScript) will be written. 
    A transformed version of the code in the index.js file is the first to be executed 
    when the SPA is loaded (via the 'npm run start' command). This 'transformed' version is done 
    behind the scenes by scripts that transform and optimize the code. The 'npm run start' command
    (a.k.a. the development server: local host) watches the 'root' directs to the index.html file 
    found within the public folder. The App.js file is a component. In order to render/use the App.js 
    component, we must export the file in App.js and import it in this file (index.js) or the file in 
    which you plan to use the code. The index.html file takes instruction from the index.js file. The
    render method within index.js instructs the .html file to display the <App /> component in the 'root' div.
